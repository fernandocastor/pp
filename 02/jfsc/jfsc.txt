CAP1
1) ANEXO

2) â€” 
1) Vivacidade. Garante que a mordomia do serviÃ§o serÃ¡ ordinal, porÃ©m, nÃ£o estabeleceu tempo ou qualquer outra garantia.
2) Vivacidade. Garante que em algum momento (eventualidade) a queda irÃ¡ acontecer.
3) seguranÃ§a. Acesso de mais de 1 processo Ã  regiÃ£o critica significa que nÃ£o ha computaÃ§Ã£o coerente. Ou seja, quando uma coisa mÃ¡ nÃ£o irÃ¡ acontecer.
4) Vivacidade. A eventualidade da interrupÃ§Ã£o provocarÃ¡ uma notificaÃ§Ã£o (mensagem). Um notificaÃ§Ã£o serÃ¡ coisa boa acontecendo.
5) Vivacidade. A eventualidade da interrupÃ§Ã£o provocarÃ¡ uma notificaÃ§Ã£o (mensagem). Um notificaÃ§Ã£o serÃ¡ coisa boa acontecendo.
6) SeguranÃ§a. Sempre terei de ganhar mais dinheiro. Assim, a coisa mÃ¡(para elas) Ã© que as empresas precisarÃ£o me pagar mais.
7) SeguranÃ§a. A coisa boa Ã© que ha a possibilidade de planejamento.
8) Vivacidade. A coisa boa Ã© que sempre haveria soluÃ§Ã£o em harvard.

6)
a)
var x; 
x = 1 / ((1 - 0.6) + (0.6/N));
x = 1 / (0.4 + 0.6/N); // N INFINITO
x = 1/ 0.4
x = 2.5

b)  
0.3 + (0.7/N) = (0.6/x) + (1.4/N)
0.3 - (0.7/N) = 0.6/x
(0.3N - 0.7/N) = 0.6/x 
x = (0.3N - 0.7/N) / 0.6

c)

8)â€”

 1 / [1 - p + (p / 9)] = 5 â†’ 1 / [(9 - 9p + p) / 9] = 5 â†’ 9/(p + 9-9p) = 5 â†’  p - 9p = (9/5) - 9 â†’  -8p = (9/5) - 9 â†’(-1).8p = 9-9/5 â†’ p = 7.2 / 8 â†’ p = 0.9

Cerca de 90% do software precisa ser paralelizavel

CAP2

11
RESPOSTA

NÃ£o satisfaz a propriedade de exclusÃ£o mÃºtua, pois, nunca serÃ¡ possÃ­vel entrar na regiÃ£o crÃ­tica. AlÃ©m disso, nenhuma thread poderÃ¡ obter o lock no fluxo do sistema, causando inaniÃ§Ã£o. Finalmente, ha uma espera infinita pela liberaÃ§Ã£o do Lock() que nÃ£o ocorrerÃ¡.

Prova: 
READğ‘ (turn != me) â†’ READğ‘ (busy == false) â†’ WRITEğ‘ (busy = true) â†’ READğ‘ (turn != me) â†’ READğ‘ (busy == true)  â†’ WRITEğ‘ (turn = me) â†’ READğ‘ (busy == true); //loop infinito
READğ˜£ (turn != me) â†’ READğ˜£ (busy == true) â†’ WRITEğ˜£ (turn = me) â†’ READğ˜£ (busy == true); //loop infinito
READğ˜¯ (turn != me) â†’ READğ˜¯ (busy == true) â†’ WRITEğ˜¯ (turn = me) â†’ READğ˜¯ (busy == true); //loop infinito

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

13
RESPOSTA:

Levando em consideraÃ§Ã£o que ha uma um processo de concepÃ§Ã£o da arvore binÃ¡ria e um processo de indexaÃ§Ã£o/reindexaÃ§Ã£o 
bem definido na entrada method TreeLock:

Class Peterson implements Locks {
â€¦
private Peterson pFather, pChildLeft, pChildRight;
private int key;
private int count = 0; // atÃ© 2

public void treeLock(){
	this.incrementCount();
	int i = indexing2Threads(ThreadID.get())// NÃ£o importa se ela Ã© uma thread 
									//criada no inÃ­cio da criaÃ§Ã£o da arvore. 
									//Basta que o processo de indexaÃ§Ã£o proverÃ¡ o valor 0 ou 1
	int j = j-i;
	flag[i] = true;
	victim = i
	while(flag[j] && victim==i && pFather.getCount == 2){}; //AlÃ©m de esperar devido a exclusÃ£o mutua em seu leaf, a
											      // thread precisarÃ¡ identificar se ha possibilidade de inserir-												     // se no nÃ³ seguinte ( o pai)
	
	if(pFather != null ){ //Existe mais um nÃ³ Pai a caminho da raiz da Ã¡rvore 
		pFather.treeLock();
	}
} 

public void treeUnlock(){
	int i = indexing2Threads(ThreadID.get())// NÃ£o importa se ela Ã© uma thread 
									//criada no inÃ­cio da criaÃ§Ã£o da arvore. 
									//Basta que o processo de indexaÃ§Ã£o proverÃ¡ o valor 0 ou 1
	flag[i] = false;
	Peterson child = findNextChildOfThisThreadID(ThreadID.get()) // busca na arvore que Ã© o proximo nÃ³. 
													    // Caso nÃ£o exista, retorna nulo
	if(child != null){
		pChild.treeUnlock();
	}
	this.decrementCount();
}

Acerca da ExclusÃ£o MÃºtua
a) cada thread entra e sai do seu leaf respeitando a propriedade de exclusÃ£o mÃºtua. Alem disso, a passagem de um leaf para outro sÃ³ Ã© feita se houver menos de 2 threads no nÃ³ a ser inserida a thread.

Livre de deadlocks
a) NÃ£o ha dependÃªncias circulares e ha uma seÃ§Ã£o crÃ­tica acessÃ­vel via algoritmo de Lock de Peterson.

Livre de â€œfomeâ€
a) NÃ£o ha garantia de quando serÃ¡ provido o acesso a seÃ§Ã£o critica ou ao proximo leaf mais perto da raiz, porem, ha a garantia que EVENTUALMENTE isso vai acontecer.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
15
RESPOSTA

Sobre a exclusÃ£o mÃºtua. Ha a possibilidade de mais de 1 thread acessar a seÃ§Ã£o crÃ­tica ao mesmo tempo. 
WRITEğ‘ (x = IDğ‘) â†’  WRITEğ˜£ (x = IDğ˜£) â†’ READğ‘ (y != -1) â†’ READğ˜£ (y != -1);
WRITEğ˜¤ (x = IDğ˜¤) â†’ READğ‘ (x != i)  â†’ READğ˜£ (x != i);// 2 locks simultÃ¢neos

Portanto, nÃ£o satisfaz a exclusÃ£o mÃºtua.

Sobre liberdade de â€œfomeâ€. O algoritmo pode cair em dead lock e o acesso a seÃ§Ã£o crÃ­tica pode nunca ser provido. Portanto, nÃ£o Ã© um algoritmo que satisfaz a propriedade de starvation-free
