Questão 101
-----------

O mecanismo de fine-grained synchronization requer que os locks do nó
predecessor e do nó corrente sejam adquiridos nessa ordem. Portanto,
este mecanismo apresenta "locking coupling" o que pode ocasionar deadlocks.

Para garantir que não haverá deadlock, o mecanismo exige que todos os métodos
adquiram os locks (pred e curr) sempre na mesma ordem.

Questão 102
-----------

The fine-grained add() method is linearizable since it has a linearization
point. In case of a successful execution of add() (in other words, the element
to be added is not already in the list), the linearization point is when the
node with next higher key is locked.

Questão 103
-----------

Optimistic and lazy locking algorithms follow the same locking protocol as
fine-grained, thus they also have lock coupling.

These algorithms follows the same approach from fine-grained to avoid deadlock:
all methods acquire locks in the same order (predecessor and current), starting
at the head and following next references toward the tail.

Questão 105
-----------

public boolean contains(T item) {
    int key = item.hashCode();
    head.lock();
    Node pred = head;

    try {
        Node curr = pred.next;
        curr.lock();
        try {
            while (curr.key < key) {
                pred.unlock();
                pred = curr;
                curr = curr.next;
                curr.lock();
            }

            if (curr.key == key) {
                return false;
            }

        } finally {
            curr.unlock();
        }
    } finally {
        pred.unlock();
    }
}

Questão 106
-----------

Yes, as long as the locking order in remove() and contains() methods are
changed as well. The important thing to avoid deadlock in optimistic
synchronization approach is all methods acquire locks in the same order.

Questão 108
-----------

Since the list is traversed from head to tail, there is no way to access the
current node without have accessed the predecessor node. Additionally, the
locking order in add() is predecessor and then the current node.

As long as the predecessor's lock is held, no other thread is supposed to
access the current node. Therefore, acquiring the current's lock is not
really mandatory.

Questão 110
-----------

No, because it would break the loop that searches for the node to be removed or added, since there would be no
reference to the next node in the list. The following examples shows that behaviour:

Consider this list:

--------    -----    -----    -----    --------
| head | -> | a | -> | c | -> | d | -> | tail |
--------    -----    -----    -----    --------

And remove(a) and add(b) running in parallel. Now consider that add(a) is iterating through the list's nodes until
it find c (so it can inserts b between a and c).
Then remove(a) acquires the lock for head and a and sets a.next to null just before add method do this:

    pred = a;
    curr = a.next;

In the next loop step a NullPointerException would be raised.
A way to avoid that, would be to check if curr is null, if so, try to assign curr to pred.next again.

Questão 112
-----------

This can't be done and the following example proves it:

Consider this list:

--------    -----    -----    -----    --------
| head | -> | a | -> | c | -> | d | -> | tail |
--------    -----    -----    -----    --------

And remove(c) and add(b) are called at the "same time". Then, when remove(c) finds its pred and curr, before acquiring
any lock, (pred=a, curr=c) it gets scheduled. After that, add(b) continues to run and completes its execution.
When remove(c) returns, pred.next (a) is not equals to c anymore, so if we continue the element removal pred.next will
be set to d, ignoring the insertion of b.
So we must continue checking pred.next.


Questão 115
-----------

No, we can start over from pred, instead from head. Because that could happened lots of node insertions after pred,
that would need to reposition the new node to be inserted, in order to maintain the key order requirement.

Questão 118
-----------

This cannot happen because the implementation guarantees that if a node is to be added, all the nodes that are marked
before it are removed in the list traversal, to find the place to put that node.
So, if a node is logically removed and a node with the same value is going to be added, that removed node will be
phisically removed from the list, in the Window.find method, because it is less or equal than the key to be added.
